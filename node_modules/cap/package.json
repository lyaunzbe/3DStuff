{
  "name": "cap",
  "version": "0.0.5",
  "author": {
    "name": "Brian White",
    "email": "mscdex@mscdex.net"
  },
  "description": "A cross-platform binding for performing packet capturing with node.js",
  "main": "./lib/Cap",
  "engines": {
    "node": ">=0.8.0"
  },
  "keywords": [
    "pcap",
    "packet",
    "capture",
    "libpcap",
    "winpcap"
  ],
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/mscdex/cap/raw/master/LICENSE"
    }
  ],
  "repository": {
    "type": "git",
    "url": "http://github.com/mscdex/cap.git"
  },
  "scripts": {
    "install": "node-gyp rebuild"
  },
  "gypfile": true,
  "readme": "\nDescription\n===========\n\nA cross-platform binding for performing packet capturing with [node.js](http://nodejs.org/).\n\nThis binding is tested on Windows and Linux.\n\n\nRequirements\n============\n\n* [node.js](http://nodejs.org/) -- v0.8.0 or newer\n\n* For Windows: [WinPcap](http://www.winpcap.org/install/default.htm)\n\n* For *nix: libpcap and libpcap-dev packages\n\n\nInstall\n============\n\n    npm install cap\n\n\nExamples\n========\n\n* Capture and decode all outgoing TCP data packets destined for port 80 on the interface for 192.168.0.10:\n\n```javascript\nvar Cap = require('cap').Cap,\n    decoders = require('cap').decoders,\n    PROTOCOL = decoders.PROTOCOL;\n\nvar c = new Cap(),\n    device = Cap.findDevice('192.168.0.10'),\n    filter = 'tcp and dst port 80',\n    bufSize = 10 * 1024 * 1024,\n    buffer = new Buffer(65535);\n\nvar linkType = c.open(device, filter, bufSize, buffer);\n\nc.setMinBytes && c.setMinBytes(0);\n\nc.on('packet', function(nbytes, trunc) {\n  console.log('packet: length ' + nbytes + ' bytes, truncated? '\n              + (trunc ? 'yes' : 'no'));\n\n  // raw packet data === buffer.slice(0, nbytes)\n\n  if (linkType === 'ETHERNET') {\n    var ret = decoders.Ethernet(buffer);\n\n    if (ret.info.type === PROTOCOL.ETHERNET.IPV4) {\n      console.log('Decoding IPv4 ...');\n\n      ret = decoders.IPV4(buffer, ret.offset);\n      console.log('from: ' + ret.info.srcaddr + ' to ' + ret.info.dstaddr);\n\n      if (ret.info.protocol === PROTOCOL.IP.TCP) {\n        var datalen = ret.info.totallen - ret.hdrlen;\n\n        console.log('Decoding TCP ...');\n\n        ret = decoders.TCP(buffer, ret.offset);\n        console.log(' from port: ' + ret.info.srcport + ' to port: ' + ret.info.dstport);\n        datalen -= ret.hdrlen;\n        console.log(buffer.toString('binary', ret.offset, ret.offset + datalen));\n      } else if (ret.info.protocol === PROTOCOL.IP.UDP) {\n        console.log('Decoding UDP ...');\n\n        ret = decoders.UDP(buffer, ret.offset);\n        console.log(' from port: ' + ret.info.srcport + ' to port: ' + ret.info.dstport);\n        console.log(buffer.toString('binary', ret.offset, ret.offset + ret.info.length));\n      } else\n        console.log('Unsupported IPv4 protocol: ' + PROTOCOL.IP[ret.info.protocol]);\n    } else\n      console.log('Unsupported Ethertype: ' + PROTOCOL.ETHERNET[ret.info.type]);\n  }\n});\n```\n\n* List all network devices:\n\n```javascript\nvar Cap = require('cap').Cap;\n\nconsole.dir(Cap.deviceList());\n\n// example output on Linux:\n// [ { name: 'eth0',\n//     addresses:\n//      [ { addr: '192.168.0.10',\n//          netmask: '255.255.255.0',\n//          broadaddr: '192.168.0.255' } ] },\n//   { name: 'nflog',\n//     description: 'Linux netfilter log (NFLOG) interface',\n//     addresses: [] },\n//   { name: 'any',\n//     description: 'Pseudo-device that captures on all interfaces',\n//     addresses: [] },\n//   { name: 'lo',\n//     addresses:\n//      [ { addr: '127.0.0.1', netmask: '255.0.0.0' },\n//        { addr: '::1',\n//          netmask: 'ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff' } ],\n//     flags: 'PCAP_IF_LOOPBACK' } ]\n```\n\n\nAPI\n===\n\nCap events\n----------\n\n* **packet**(< _integer_ >nbytes, < _boolean_ >truncated) - A packet `nbytes` in size was captured. `truncated` indicates if the entire packet did not fit inside the _Buffer_ supplied to open().\n\n\nCap methods\n-----------\n\n* **(constructor)**() - Creates and returns a new Cap instance.\n\n* **open**(< _string_ >device, < _string_ >filter, < _integer_ >bufSize, < _Buffer_ >buffer) - _(void)_ - Opens `device` and starts capturing packets using `filter`. `bufSize` is the size of the internal buffer that libpcap uses to temporarily store packets until they are emitted. `buffer` is a Buffer large enough to store one packet. If open() is called again without a previous call to close(), an implicit close() will occur first.\n\n* **close**() - _(void)_ - Stops capturing.\n\n* **setMinBytes**(< _integer_ >nBytes) - _(void) - **(Windows ONLY)** This sets the minimum number of packet bytes that must be captured before the full packet data is made available. If this value is set too high, you may not receive any packets until WinPCap's internal buffer fills up. Therefore it's generally best to pass in 0 to this function after calling open(), despite it resulting in more syscalls.\n\n\nCap static methods\n------------------\n\n* **findDevice**([< _string_ >ip]) - _mixed_ - If `ip` is given, the (first) device name associated with `ip`, or undefined is returned if not found. If `ip` is not given, the device name of the first non-loopback device is returned.\n\n* **deviceList**() - _array_ - Returns a list of available devices and related information.\n\n\nDecoders static methods\n-----------------------\n\nThe following methods are available off of `require('cap').decoders`. They parse the relevant protocol header and return an object containing the parsed information:\n\n* Link Layer Protocols\n\n    * **Ethernet**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n* Internet Layer Protocols\n\n    * **IPV4**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **IPV6**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **ICMPV4**(< _Buffer_ buf, < _integer_ >nbytes[, < _integer_ >bufOffset=0])\n\n* Transport Layer Protocols\n\n    * **TCP**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **UDP**(< _Buffer_ buf[, < _integer_ >bufOffset=0])\n\n    * **SCTP**(< _Buffer_ buf, < _integer_ >nbytes[, < _integer_ >bufOffset=0])\n",
  "readmeFilename": "README.md",
  "_id": "cap@0.0.5",
  "dist": {
    "shasum": "cf6490c1cb8a19078bc2af866891345969614467"
  },
  "_from": "cap"
}
